# Requirements by BDD Rule

## 概要

このルールは、Behavior-Driven Development (BDD) アプローチを使用した要件整理のフレームワークを定義します。Given-When-Then パターンとビジネスルールの効果的な整理方法を提供し、複雑なビジネスロジックを明確に表現することを目的としています。

## BDD 要件整理の原則

### 1. Given-When-Then パターンの活用

すべての受入基準は Given-When-Then 形式で記述し、具体的な振る舞いを明確にします。

**基本構造:**
```gherkin
Given [前提条件・初期状態]
When [実行されるアクション・イベント]
Then [期待される結果・振る舞い]
```

**複合条件の場合:**
```gherkin
Given [前提条件1]
  And [前提条件2]
When [アクション]
Then [結果1]
  And [結果2]
```

### 2. Rule キーワードによるビジネスルール整理

複雑なビジネスロジックは `Rule` キーワードを使用して構造化します。

**構造:**
```gherkin
Rule: [ビジネスルール名]
  [ルールの説明]

  Example: [シナリオ名]
    Given [前提条件]
    When [アクション]
    Then [結果]

  Example: [別のシナリオ名]
    Given [異なる前提条件]
    When [同じアクション]
    Then [異なる結果]
```

### 3. データテーブルによる実例表現

複雑なビジネスルールや多数のパターンがある場合は、データテーブルを使用して実例を整理します。

## 要件文書への適用

### User Stories での BDD 適用

```markdown
## User Story: [Story Name]

**As a** [user role]
**I want** [functionality]  
**So that** [business value]

### Acceptance Criteria (BDD Format)

#### Rule: [ビジネスルール名]
[ルールの説明]

**Example: [正常系シナリオ名]**
```gherkin
Given [前提条件]
When [ユーザーアクション]
Then [期待される結果]
  And [追加の結果]
```

**Example: [異常系シナリオ名]**
```gherkin
Given [異常な前提条件]
When [同じアクション]
Then [エラー処理の結果]
```

#### Rule: [別のビジネスルール]
[複雑なルールの説明]

**Data Table Example:**
| 入力条件A | 入力条件B | 期待結果 | 備考 |
|----------|----------|---------|------|
| 値1      | 値A      | 結果X   | 正常系 |
| 値2      | 値B      | 結果Y   | 境界値 |
| 値3      | 値C      | エラーZ  | 異常系 |

```gherkin
Given 入力条件A が "<入力条件A>"
  And 入力条件B が "<入力条件B>"
When システムが処理を実行する
Then 結果は "<期待結果>" になる

Examples:
| 入力条件A | 入力条件B | 期待結果 |
| 値1      | 値A      | 結果X   |
| 値2      | 値B      | 結果Y   |
| 値3      | 値C      | エラーZ  |
```
```

### Tool Definitions での BDD 適用

```markdown
## Tool: [tool-name]

### Behavior Specification (BDD Format)

#### Rule: [ツールの主要ビジネスルール]
[ルールの説明]

**Example: [正常処理シナリオ]**
```gherkin
Given 有効な入力パラメータが提供される
  And システムが正常状態である
When ツールが実行される
Then 構造化された結果が返される
  And ドメインイベントが生成される
```

**Example: [エラーハンドリングシナリオ]**
```gherkin
Given 無効な入力パラメータが提供される
When ツールが実行される
Then Result.err が返される
  And エラーメッセージが含まれる
```

#### Rule: [入力検証ルール]
複雑な入力検証ロジックの場合

**Validation Data Table:**
| 入力値 | バリデーション結果 | エラーメッセージ |
|-------|------------------|----------------|
| 正常値 | Valid           | -              |
| 空文字 | Invalid         | "必須項目です"    |
| 長すぎ | Invalid         | "文字数制限超過"  |

```gherkin
Given 入力値が "<入力値>"
When バリデーションが実行される
Then 結果は "<バリデーション結果>" になる
  And エラーメッセージは "<エラーメッセージ>" になる

Examples:
| 入力値 | バリデーション結果 | エラーメッセージ |
| 正常値 | Valid           | -              |
| 空文字 | Invalid         | "必須項目です"    |
```
```

## BDD 記述のベストプラクティス

### 1. 具体性の原則
- 抽象的な表現を避け、具体的な値や状態を使用
- 「適切な」「正しい」などの曖昧な表現を避ける

### 2. 独立性の原則
- 各シナリオは他のシナリオに依存しない
- 前提条件は明確に記述する

### 3. 実行可能性の原則
- 自動テストとして実行可能な形で記述
- 検証可能な結果を定義

### 4. ビジネス言語の使用
- 技術的な実装詳細ではなく、ビジネス価値に焦点
- ステークホルダーが理解できる言葉を使用

## 複雑なビジネスルールの整理パターン

### パターン1: 状態遷移ルール
```gherkin
Rule: ワークフロー状態遷移
  意思決定プロセスは定義された状態遷移に従う

  Example: 正常な状態遷移
    Given ワークフローが "初期" 状態である
    When "課題定義" アクションが実行される
    Then ワークフロー状態が "課題定義済み" になる

  Example: 無効な状態遷移
    Given ワークフローが "初期" 状態である
    When "選択肢評価" アクションが実行される
    Then エラー "無効な状態遷移" が発生する
```

### パターン2: 条件分岐ルール
```gherkin
Rule: 評価基準による選択肢フィルタリング
  選択肢は設定された評価基準に基づいてフィルタリングされる

  Background:
    Given 以下の選択肢が存在する:
      | 選択肢ID | コスト | リスク | 実現可能性 |
      | A       | 高     | 低     | 高        |
      | B       | 低     | 高     | 低        |
      | C       | 中     | 中     | 高        |

  Example: コスト重視フィルタ
    Given 評価基準が "コスト重視" に設定されている
    When フィルタリングが実行される
    Then 選択肢 B が最上位に表示される

  Example: リスク重視フィルタ
    Given 評価基準が "リスク重視" に設定されている
    When フィルタリングが実行される
    Then 選択肢 A が最上位に表示される
```

### パターン3: 計算ロジックルール
```gherkin
Rule: 選択肢スコア計算
  各選択肢のスコアは重み付けされた評価項目の合計で計算される

  Example: スコア計算
    Given 選択肢に以下の評価がある:
      | 評価項目   | 点数 | 重み |
      | コスト     | 8    | 0.3  |
      | リスク     | 6    | 0.4  |
      | 実現可能性 | 9    | 0.3  |
    When スコアが計算される
    Then 総合スコアは 7.3 になる
      # (8*0.3 + 6*0.4 + 9*0.3 = 2.4 + 2.4 + 2.7 = 7.5)
```

## 検証チェックリスト

BDD 要件を作成する際の確認項目:

- [ ] Given-When-Then 形式で記述されている
- [ ] 各シナリオが独立して実行可能
- [ ] 具体的な値や状態が使用されている
- [ ] ビジネス言語で記述されている
- [ ] 複雑なルールは Rule キーワードで整理されている
- [ ] データテーブルが適切に使用されている（複雑なビジネスルールに対してのみ）
- [ ] 正常系・異常系の両方がカバーされている

## TDDへの接続
BDDのプラクティスは、実装フェーズにおいて、自然にTDDへ接続することができる

このルールに従うことで、要件の明確性と実装の品質を同時に向上させることができます。